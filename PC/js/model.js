var container, stats;var materials = [];var camera, scene, renderer;var mouseX = 0, mouseY = 0;var windowHalfX = window.innerWidth / 2;var windowHalfY = window.innerHeight*0.8 / 2;var sunLight, sunLight2, sunLight3, bigLight;var group;var raycaster;var mouse = new THREE.Vector2();var snowSpritePoints;init();animate();function init() {var canvasdiv = document.getElementById("canvas");container = document.createElement( 'div' );canvasdiv.appendChild( container );scene = new THREE.Scene();group = new THREE.Group();camera = new THREE.PerspectiveCamera( 90, window.innerWidth / (window.innerHeight*0.8), 2, 10000 );// camera.position.z = 45;// camera.position.y = 0;camera.position.set( 0, 200, 400 );// camera.position.x = 0;camera.up.x = 0;//设置相机的上为「x」轴方向camera.up.y = 1;//设置相机的上为「y」轴方向camera.up.z = 0;//设置相机的上为「z」轴方向// camera.lookAt( {x:0, y:-10, z:0 } );// camera.position.set(0,15,40);camera.lookAt(scene.position); // scene// SETUP ORBIT CONTROL OF THE CAMERAvar controls = new THREE.OrbitControls(camera);controls.damping = 0.2;var ambient = new THREE.AmbientLight( 0x444444 );group.add( ambient );// var directionalLight = new THREE.DirectionalLight( 0xffffff,1);// directionalLight.position.set( 0, 0, 1 ).normalize();// scene.add( directionalLight );sunLight = new THREE.PointLight( 0xFFffff,1,1000);sunLight.position.set( 0, 200, -505 );group.add( sunLight );// scene.add( sunLight );group.add( new THREE.PointLightHelper( sunLight, 30 ) );sunLight2 = new THREE.PointLight( 0xFFffff,0.8,1000);sunLight2.position.set( -140, 250, -250 );group.add( sunLight2 );// scene.add( sunLight2 );group.add( new THREE.PointLightHelper( sunLight2, 30 ) );sunLight3 = new THREE.PointLight( 0xFFffff,0.8,1000);sunLight3.position.set( -140, 250, 0 );group.add( sunLight3 );// scene.add( sunLight3 );group.add( new THREE.PointLightHelper( sunLight3, 30 ) );bigLight = new THREE.PointLight( 0xFFffff,0.8,500);bigLight.position.set( 150, 500, -150 );group.add( bigLight );// scene.add( bigLight );group.add( new THREE.PointLightHelper( bigLight, 30 ) );var worldFrame = new THREE.AxisHelper(5) ;group.add(worldFrame);//modeladdModelWithMtl(scene);// UNIFORMSvar remotePosition = {type: 'v3', value: new THREE.Vector3(0,5,3)};var tvChannel = {type: 'i', value: 1};// MATERIALSvar armadilloMaterial = new THREE.ShaderMaterial();var remoteMaterial = new THREE.ShaderMaterial({   uniforms: {    remotePosition: remotePosition,  },});// CREATE REMOTE CONTROLvar remoteGeometry = new THREE.SphereGeometry(1, 32, 32);var remote = new THREE.Mesh(remoteGeometry, remoteMaterial);remote.parent = worldFrame;scene.add(remote);// LISTEN TO KEYBOARDvar keyboard = new THREEx.KeyboardState();function checkKeyboard() {  if (keyboard.pressed("W")){    console.log("hihihi")    floor.position.z -= 0.1;  }  else if (keyboard.pressed("S"))    remotePosition.value.z += 0.1;  if (keyboard.pressed("A"))    remotePosition.value.x -= 0.1;  else if (keyboard.pressed("D"))    remotePosition.value.x += 0.1;  if (keyboard.pressed("R"))    remotePosition.value.y += 0.1;  else if (keyboard.pressed("F"))    remotePosition.value.y -= 0.1;  for (var i=1; i<4; i++)  {    if (keyboard.pressed(i.toString()))    {      tvChannel.value = i;      break;    }  }  remoteMaterial.needsUpdate = true; // Tells three.js that some uniforms might have changed}// scene.fog = new THREE.FogExp2( 0x000000, 0.0008 );scene.fog = new THREE.Fog( 0, 1000, 10000 );geometry = new THREE.Geometry();var textureLoader = new THREE.TextureLoader();var sprite1 = textureLoader.load( "textures/cold.png" );// sprite2 = textureLoader.load( "textures/snowflake2.png" );for ( i = 0; i < 100; i ++ ) {  var vertex = new THREE.Vector3();  vertex.x = Math.random(0,1)*2+30;  vertex.y = Math.random(0,1)*2+5;  vertex.z = Math.random(0,1)*2+5;  geometry.vertices.push( vertex );}parameters = [  // [ [0.95, 0.1, 0.5], sprite3, 15  ],  [ [0.90, 0.05, 0.5], sprite1, 2 ],  // [ [0.85, 0, 0.5], sprite5, 8 ],  // [ [0.80, 0, 0.5], sprite4, 5 ]];for ( i = 0; i < parameters.length; i ++ ) {  color  = parameters[i][0];  sprite = parameters[i][1];  size   = parameters[i][2];  materials[i] = new THREE.PointsMaterial( { size: size, map: sprite, blending: THREE.AdditiveBlending, depthTest: false, transparent : true } );  materials[i].color.setHSL( color[0], color[1], color[2] );  var particles = new THREE.Points( geometry, materials[i] );  particles.rotation.x = Math.random() * 6;  particles.rotation.y = Math.random() * 6;  particles.rotation.z = Math.random() * 6;// particles.parent = worldFrame;  group.add( particles );}raycaster = new THREE.Raycaster();renderer = new THREE.WebGLRenderer();renderer.setClearColor(0x000000); // white background colourrenderer.setPixelRatio( window.devicePixelRatio );renderer.setSize( window.innerWidth, window.innerHeight * 0.8 );renderer.sortObjects = false;container.appendChild( renderer.domElement );stats = new Stats();container.appendChild( stats.dom );document.addEventListener( 'mousemove', onDocumentMouseMove, false );// document.addEventListener( 'mousemove', onDocumentMouseMove, false );// document.addEventListener( 'touchstart', onDocumentTouchStart, false );// document.addEventListener( 'touchmove', onDocumentTouchMove, false );//// window.addEventListener( 'resize', onWindowResize, false );}function addModelWithMtl ( scene ) {// modelvar onProgress = function ( xhr ) {  if ( xhr.lengthComputable ) {    var percentComplete = xhr.loaded / xhr.total * 100;    console.log( Math.round(percentComplete, 2) + '% downloaded' );  }};var onError = function ( xhr ) { };THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );var mtlLoader = new THREE.MTLLoader();mtlLoader.setTexturePath( 'obj/keting/' );mtlLoader.setPath( 'obj/keting/' );mtlLoader.load( 'Changj.mtl', function( materials ) {  for (var i = 0; i < materials.length; i++) {    materials[i].needsUpdate = false;  };  materials.preload();  var objLoader = new THREE.OBJLoader();  objLoader.setMaterials( materials );  objLoader.setPath( 'obj/keting/' );  objLoader.load( 'Changj.obj', function ( object ) {    object.scale.x = object.scale.y = object.scale.z = 15;    object.position.y = - 30;    object.position.z = -50;    group.add(object)    scene.add( group );  }, onProgress, onError );});}// function onWindowResize() {//   windowHalfX = window.innerWidth / 2;//   windowHalfY = window.innerHeight / 2;//   camera.aspect = window.innerWidth / window.innerHeight;//   camera.updateProjectionMatrix();//   renderer.setSize( window.innerWidth, window.innerHeight );// }function onDocumentMouseMove( event ) {event.preventDefault();mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;mouse.y = - ( event.clientY / (window.innerHeight*0.8) ) * 2 + 1;// mouseX = ( event.clientX - windowHalfX ) / 2;// mouseY = ( event.clientY - windowHalfY ) / 2;}function onDocumentTouchStart( event ) {if ( event.touches.length === 1 ) {  event.preventDefault();  mouseX = event.touches[ 0 ].pageX - windowHalfX;  mouseY = event.touches[ 0 ].pageY - windowHalfY;}}function onDocumentTouchMove( event ) {  if ( event.touches.length === 1 ) {    event.preventDefault();    mouseX = event.touches[ 0 ].pageX - windowHalfX;    mouseY = event.touches[ 0 ].pageY - windowHalfY;  }}//function animate() {  requestAnimationFrame( animate );  stats.begin();  render();  stats.end();  // stats.update();}var rotateAxis = new THREE.Vector3(100,50,0)var radIncrement;var rad;function render() {  radIncrement = 0.0001;  rad = 0;  var time = Date.now() * 0.00005;  // camera.position.x += ( mouseX - camera.position.x ) ;  // camera.position.y += ( - mouseY - camera.position.y ) ;  // camera.updateMatrixWorld();  // raycaster.setFromCamera( mouse, camera );  // // calculate objects intersecting the picking ray  // var intersects = raycaster.intersectObjects( scene.children );  // for ( var i = 0; i < intersects.length; i++ ) {  //   console.log("get 344 "+i)  //   console.log(intersects[i])  //   // intersects[ i ].object.material.color.set( 0xff0000 );  // }  // camera.lookAt( scene.position );  for ( i = 0; i < scene.children.length; i ++ ) {    var object = scene.children[ i ];    if ( object instanceof THREE.Group ) {      for ( j = 0; j < object.children.length; j ++ ) {        var object2 = object.children[ j ];        if(object2 instanceof THREE.Group) {          for (var k = 0; k < object2.children.length; k++) {            var object3 = object2.children[ k ];            if(object3 instanceof THREE.Points) {              rad += radIncrement;              object2.rotateOnAxis(new THREE.Vector3(-400,-200,-200).normalize(), 0.075)              // object3.rotation.x = time*10            }          }          // object2.rotation.y = time * ( i < 4 ? i + 1 : - ( i + 1 ) );        }      }    }  }  for (var i = 0; i < scene.children.length; i++) {    var object = scene.children[i];    if(object instanceof THREE.Group) {      for ( j = 0; j < object.children.length; j ++ ) {        var object2 = object.children[ j ];        if(object2 instanceof THREE.Points) {          //可能的解决方案..重置vertices的位置 但是没有用            // var vertices = object2.geometry.vertices;          // vertices.forEach(function (v) {          //   v.y = v.y - 1;          //   if (v.y == 0) v.y = 500;          // });          // snowGeometry.verticesNeedUpdate = true;          object2.position.y -= 1;          if(object2.position.y == 0) {            object2.position.y = 500;          }          // object2.rotation.y = time * ( i < 4 ? i + 1 : - ( i + 1 ) );        }      }    }  };  // for ( i = 0; i < materials.length; i ++ ) {  //   color = parameters[i][0];  //   h = ( 360 * ( color[0] + time ) % 360 ) / 360;  //   materials[i].color.setHSL( h, color[1], color[2] );  // }  renderer.render( Scene, camera );}